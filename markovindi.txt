//@version=5
indicator("Markov Forward Probability [Structural Regime Model]", overlay=false, max_bars_back=1000)

// =====================
// Inputs
// =====================
lookback_period   = input.int(50, "Momentum Lookback (n)", minval=1)
atr_threshold     = input.float(0.5, "ATR Threshold Multiplier", step=0.1)
atr_length        = input.int(50, "ATR Length", minval=1)
memory_decay      = input.float(0.97, "Transition Memory Decay", minval=0.90, maxval=0.999)
vol_percentile_lb = input.int(100, "ATR Percentile Lookback")
use_second_order  = input.bool(true, "Use 2nd Order Markov")
ev_ema_length     = input.int(20, "EV EMA Length", minval=1)
min_sample_size   = input.float(5.0, "Minimum Effective Sample")

// Momentum tuning (less sensitive)
smooth_len      = input.int(5, "Momentum Smoothing (EMA)", minval=1, group="Momentum Filter")
trigger_thresh  = input.float(0.8, "Trend Entry Threshold (ATR)", step=0.1, group="Momentum Filter")
exit_thresh     = input.float(0.6, "Trend Exit Threshold (ATR)", step=0.1, group="Momentum Filter")

// Structural filters
range_lookback  = input.int(50, "Range Lookback", group="Structural Filter")
macro_len       = input.int(100, "Macro Trend EMA", group="Structural Filter")
micro_len       = input.int(20, "Micro Trend EMA", group="Structural Filter")
slope_len       = input.int(20, "Macro Slope Length", group="Structural Filter")
min_trend_bars  = input.int(10, "Minimum Trend Duration", group="Structural Filter")

// =====================
// Constants
// =====================
var int UPTREND   = 1
var int NEUTRAL   = 0
var int DOWNTREND = -1

color_up   = color.new(color.green, 0)
color_neu  = color.new(color.blue, 0)
color_down = color.new(color.red, 0)

state_index(s) => s == 1 ? 2 : (s == 0 ? 1 : 0)

// =====================
// 1. Smoothed Momentum
// =====================
atr_value = ta.atr(atr_length)
price_change = close - close[lookback_period]
raw_norm_change = atr_value > 0 ? price_change / atr_value : 0.0
smoothed_change = ta.ema(raw_norm_change, smooth_len)

// =====================
// 2. Structural Filters
// =====================
macro_baseline = ta.ema(close, macro_len)
micro_baseline = ta.ema(close, micro_len)

macro_up   = micro_baseline > macro_baseline
macro_down = micro_baseline < macro_baseline

macro_slope = macro_baseline - macro_baseline[slope_len]
strong_up_slope   = macro_slope > 0
strong_down_slope = macro_slope < 0

// Compression detection
hh = ta.highest(close, range_lookback)
ll = ta.lowest(close, range_lookback)
range_width = hh - ll
range_expansion = range_width / ta.sma(range_width, range_lookback)

// =====================
// 3. Persistent Structural State Machine
// =====================

// --- Additional structural refinements ---
slope_flat_threshold = input.float(0.0001, "Slope Flat Threshold", group="Structural Filter")

flat_slope = math.abs(macro_slope) < slope_flat_threshold

// Statistical compression detection
range_ma  = ta.sma(range_width, range_lookback)
range_std = ta.stdev(range_width, range_lookback)
compression = range_width < (range_ma - 0.5 * range_std)

// --- Persistent regime memory ---
var int state = NEUTRAL
var int trend_bars = 0

if state == state[1]
    trend_bars += 1
else
    trend_bars := 0

can_exit = trend_bars > min_trend_bars

// =====================
// State Logic
// =====================

if state == NEUTRAL
    
    // ENTER UPTREND
    if smoothed_change > trigger_thresh and macro_up and strong_up_slope and not compression
        state := UPTREND
        
    // ENTER DOWNTREND
    else if smoothed_change < -trigger_thresh and macro_down and strong_down_slope and not compression
        state := DOWNTREND


else if state == UPTREND
    
    // Exit if structure weakens
    if can_exit and (
         (macro_down and smoothed_change < -exit_thresh) or
         flat_slope or
         compression
       )
        state := NEUTRAL


else if state == DOWNTREND
    
    // Exit if structure weakens
    if can_exit and (
         (macro_up and smoothed_change > exit_thresh) or
         flat_slope or
         compression
       )
        state := NEUTRAL


// =====================
// Volatility Regime
// =====================
atr_percentile = ta.percentile_linear_interpolation(atr_value, vol_percentile_lb, 0.5)
high_vol_regime = atr_value > atr_percentile
regime_offset(s) => s ? 9 : 0

// =====================
// Transition Matrix
// =====================
var matrix<float> trans_mat = matrix.new<float>(18, 3, 1.0)
var float[] row_totals = array.new_float(18, 3.0)

if barstate.isconfirmed and bar_index > lookback_period + 2
    prev_state  = state[1]
    prev2_state = state[2]
    curr_state  = state
    
    regime_upd = regime_offset(high_vol_regime[1])
    order_upd = use_second_order ? (state_index(prev2_state) * 3 + state_index(prev_state)) : state_index(prev_state)
    
    row = regime_upd + order_upd
    col = state_index(curr_state)
    
    for r = 0 to 17
        total = 0.0
        for c = 0 to 2
            val = matrix.get(trans_mat, r, c) * memory_decay
            matrix.set(trans_mat, r, c, val)
            total += val
        array.set(row_totals, r, total)
    
    new_val = matrix.get(trans_mat, row, col) + 1.0
    matrix.set(trans_mat, row, col, new_val)
    array.set(row_totals, row, array.get(row_totals, row) + 1.0)

// =====================
// Forward Prediction
// =====================
regime_pred = regime_offset(high_vol_regime)
order_pred = use_second_order ? (state_index(state[1]) * 3 + state_index(state)) : state_index(state)
pred_row = regime_pred + order_pred

c0 = matrix.get(trans_mat, pred_row, 0)
c1 = matrix.get(trans_mat, pred_row, 1)
c2 = matrix.get(trans_mat, pred_row, 2)

total_trans = c0 + c1 + c2
effective_samples = array.get(row_totals, pred_row)

valid = effective_samples >= min_sample_size

p_down = valid ? c0 / total_trans : 0.3333
p_neu  = valid ? c1 / total_trans : 0.3333
p_up   = valid ? c2 / total_trans : 0.3333

safe_log(p) => p > 0 ? p * math.log(p) : 0.0

entropy = -(safe_log(p_up) + safe_log(p_neu) + safe_log(p_down))
entropy_norm = entropy / math.log(3)
confidence = 1.0 - entropy_norm

// =====================
// Expected Value
// =====================
alpha = 2.0 / (ev_ema_length + 1)
var float[] ev_matrix = array.new_float(18, 0.0)

if barstate.isconfirmed and bar_index > lookback_period + 2
    prev_state  = state[1]
    prev2_state = state[2]
    
    regime_upd = regime_offset(high_vol_regime[1])
    order_upd = use_second_order ? (state_index(prev2_state) * 3 + state_index(prev_state)) : state_index(prev_state)
    
    row = regime_upd + order_upd
    
    fwd_return = atr_value[1] > 0 ? (close - close[1]) / atr_value[1] : 0.0
    
    old_ev = array.get(ev_matrix, row)
    new_ev = old_ev + alpha * (fwd_return - old_ev)
    array.set(ev_matrix, row, new_ev)

expected_value = valid ? array.get(ev_matrix, pred_row) : 0.0
edge = expected_value * confidence

// =====================
// Plots
// =====================
state_color = state == UPTREND ? color_up : state == DOWNTREND ? color_down : color_neu

plot(confidence * 100, "Confidence (%)", color=state_color, linewidth=2, style=plot.style_circles)
plot(confidence * 100, "Confidence Area", color=color.new(state_color, 85), style=plot.style_area)

hline(50, "50% Confidence", color=color.new(color.gray, 50), linestyle=hline.style_dashed)
hline(0)
hline(100)

// =====================
// Dashboard
// =====================
var table info_table = table.new(position.middle_left, 2, 6, bgcolor=color.new(color.black, 15), border_width=1)

if barstate.islast
    table.cell(info_table, 0, 0, "Current State", text_color=color.white)
    table.cell(info_table, 1, 0, state == UPTREND ? "UPTREND" : state == DOWNTREND ? "DOWNTREND" : "NEUTRAL", text_color=color.white, bgcolor=state_color)
    
    table.cell(info_table, 0, 1, "Confidence", text_color=color.white)
    table.cell(info_table, 1, 1, str.tostring(confidence * 100, "#.#") + "%", text_color=color.white)
    
    table.cell(info_table, 0, 2, "Entropy", text_color=color.white)
    table.cell(info_table, 1, 2, str.tostring(entropy_norm * 100, "#.#") + "%", text_color=color.white)
    
    table.cell(info_table, 0, 3, "Expected Value", text_color=color.white)
    table.cell(info_table, 1, 3, str.tostring(expected_value, "#.###") + " ATR", text_color=color.white)
    
    table.cell(info_table, 0, 4, "Edge", text_color=color.white)
    table.cell(info_table, 1, 4, str.tostring(edge, "#.###") + " ATR", text_color=color.white)
    
    table.cell(info_table, 0, 5, "Effective N", text_color=color.white)
    table.cell(info_table, 1, 5, str.tostring(effective_samples, "#.##"), text_color=color.white)